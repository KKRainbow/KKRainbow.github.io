<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决Visual Studio Code不能识别大写锁定到ESC映射的问题]]></title>
    <url>%2F2017%2F07%2F15%2F%E8%A7%A3%E5%86%B3Visual-Studio-Code%E4%B8%8D%E8%83%BD%E8%AF%86%E5%88%AB%E5%A4%A7%E5%86%99%E9%94%81%E5%AE%9A%E5%88%B0ESC%E6%98%A0%E5%B0%84%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[起因由于我习惯于使用vim，因此无论在win下还是linux下我都把ESC和CapsLock做了交换。在使用Vscode时，我也安装了vim插件，但是在插入模式中无法使用交换后的Capslock键退出插入模式。 解决方法在设置文件中修改如下选项1&quot;keyboard.dispatch&quot;: &quot;keyCode&quot; 然后重启Vscode。 具体原因见该Vscode-vim Issue以及Vscode Issue]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lex和Yacc语法示例]]></title>
    <url>%2F2017%2F07%2F11%2FLex%E5%92%8CYacc%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[为了方便以后用到的时候能快速想起lex和yacc的语法和编译过程，在此把之前写的一些东西记录下来。 要解析的文件Interface File 123456789101112131415/*fkdlsajlkfjldskafdlksajlkfsdjlaflkdsjalkfdsjtypedef struct &#123; int32 a; int32 b; int8 c; &#125; mystruct;, out mystruct st*/interface barrelrpc &quot;Example rpc interface&quot; &#123; rpc myrpc(in int32 qqq, out String s[2048]);&#125;; Lex文件示例词法文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354%&#123;/* -*- C++ -*- */#include &lt;string&gt;#include &lt;cmath&gt;#include &quot;test.tab.hh&quot;static yy::location loc;#define YY_DECL yy::FlounderFileParser::symbol_type yylex()%&#125;%option noyywrap nounput batch nodebug noinputidenty [a-zA-Z][a-zA-Z0-9_]*int [0-9]+hex 0x[0-9a-fA-F]+blank [ \t]string \&quot;([^&quot;\n]|\\\&quot;)+\&quot;typedef typedef%&#123;#define YY_USER_ACTION loc.columns(yyleng);%&#125;%%%&#123; loc.step();%&#125;&#123;blank&#125;+ loc.step();[\n]+ loc.lines(yyleng);loc.step();&quot;/*&quot;([^\*]|(\*)*[^\*/])*&quot;*/&quot; &#123;&#125;typedef return yy::FlounderFileParser::make_TYPEDEF_KEYWORD(loc);struct return yy::FlounderFileParser::make_STRUCT_KEYWORD(loc);enum return yy::FlounderFileParser::make_ENUM_KEYWORD(loc);rpc return yy::FlounderFileParser::make_RPC_KEYWORD(loc);interface return yy::FlounderFileParser::make_INTERFACE_KEYWORD(loc);&quot;,&quot; return yy::FlounderFileParser::make_COMMA(loc);&quot;;&quot; return yy::FlounderFileParser::make_COLON(loc);&quot;&#123;&quot; return yy::FlounderFileParser::make_LBRACE(loc);&quot;&#125;&quot; return yy::FlounderFileParser::make_RBRACE(loc);&quot;(&quot; return yy::FlounderFileParser::make_LPAREN(loc);&quot;)&quot; return yy::FlounderFileParser::make_RPAREN(loc);&quot;[&quot; return yy::FlounderFileParser::make_LBRACKET(loc);&quot;]&quot; return yy::FlounderFileParser::make_RBRACKET(loc);&#123;string&#125; return yy::FlounderFileParser::make_STRING(yytext, loc);&#123;int&#125; return yy::FlounderFileParser::make_INTEGER(strtol(yytext, NULL, 10), loc);&#123;identy&#125; return yy::FlounderFileParser::make_IDENTIFIER(yytext, loc);&lt;&lt;EOF&gt;&gt; return yy::FlounderFileParser::make_END(loc);%% yacc文件语法文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163%skeleton &quot;lalr1.cc&quot;%defines%define parser_class_name &#123;FlounderFileParser&#125;%define api.value.type variant%define api.token.constructor%define parse.trace%define parse.error verbose%locations%initial-action&#123;// Initialize the initial location.//@$.begin.filename = @$.end.filename = &amp;driver.file;&#125;;%code requires &#123;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;struct FunctionParam&#123; enum &#123; IN, OUT &#125; type; string typeName; string paramName; int val;&#125;;struct FunctionDecl&#123; string name; vector&lt;FunctionParam&gt; params;&#125;;struct TypeDecl&#123; enum &#123; ARRAY, ALIAS, STRUCT, ENUM &#125;type; string name; int val; string origin;&#125;;struct FlounderFile&#123; string name; string description; vector&lt;FunctionDecl&gt; functions; map&lt;string, TypeDecl&gt; types;&#125;;&#125;%parse-param &#123;FlounderFile&amp; ff&#125;%token &lt;string&gt; IDENTIFIER &quot;identifier&quot; &lt;string&gt; STRING &quot;string&quot;;%token END 0 &quot;end of file &quot; COLON &quot;;&quot; LBRACE &quot;&#123;&quot; RBRACE &quot;&#125;&quot; LPAREN &quot;(&quot; RPAREN &quot;)&quot; LBRACKET &quot;[&quot; RBRACKET &quot;]&quot; INTERFACE_KEYWORD &quot;interface&quot; TYPEDEF_KEYWORD &quot;typedef&quot; STRUCT_KEYWORD &quot;struct&quot; ENUM_KEYWORD &quot;enum&quot; RPC_KEYWORD &quot;rpc&quot; COMMA &quot;,&quot;;%token &lt;int&gt; INTEGER;%type &lt;FunctionParam&gt; param%type &lt;vector&lt;FunctionParam&gt;&gt; params%type &lt;FunctionDecl&gt; function%type &lt;TypeDecl&gt; type%type &lt;FlounderFile&gt; types_or_functions%type &lt;string&gt; param_type param_direct%%%code &#123;yy::FlounderFileParser::symbol_type yylex();&#125;;%start interface;interface : &quot;interface&quot; IDENTIFIER STRING &quot;&#123;&quot; types_or_functions &quot;&#125;&quot; &quot;;&quot; &#123;ff=$5;ff.name = $2;ff.description = $3;&#125;;types_or_functions : %empty &#123;&#125; | type types_or_functions &#123;$$ = $2; $$.types[$1.name] = $1;&#125; | function types_or_functions &#123;$$ = $2; $$.functions.push_back($1);&#125;;type : &quot;typedef&quot; &quot;struct&quot; &quot;&#123;&quot; struct_fields &quot;&#125;&quot; param_type &quot;;&quot; &#123;$$.type=TypeDecl::STRUCT;$$.name=$6;&#125; | &quot;typedef&quot; param_type IDENTIFIER &quot;[&quot; INTEGER &quot;]&quot; &quot;;&quot;&#123;$$.type=TypeDecl::ARRAY; $$.name=$2; $$.origin=$3; $$.val=$5;&#125; | &quot;typedef&quot; &quot;enum&quot; &quot;&#123;&quot; enum_fields &quot;&#125;&quot; param_type &quot;;&quot;&#123;$$.type=TypeDecl::ENUM;$$.name=$6;&#125; | &quot;typedef&quot; param_type param_type &quot;;&quot;&#123;$$.type=TypeDecl::ALIAS;$$.name=$2;$$.origin=$3;&#125;;struct_fields : %empty | struct_fields param_type IDENTIFIER &quot;;&quot;;enum_fields : %empty | enum_fields &quot;,&quot; IDENTIFIER | IDENTIFIER;function : &quot;rpc&quot; IDENTIFIER &quot;(&quot; params &quot;)&quot; &quot;;&quot; &#123; $$.name = $2; $$.params = $4; &#125;;params : %empty &#123;&#125; | params &quot;,&quot; param &#123;$$.insert($$.begin(), $1.begin(), $1.end()); $$.push_back($3);&#125; | param &#123;$$.push_back($1);&#125;;param : param_direct param_type IDENTIFIER &#123; $$.type = $1 == &quot;in&quot; ? FunctionParam::IN : FunctionParam::OUT; $$.typeName = $2; $$.paramName = $3; &#125; | param_direct param_type IDENTIFIER &quot;[&quot; INTEGER &quot;]&quot;&#123; $$.type = $1 == &quot;in&quot; ? FunctionParam::IN : FunctionParam::OUT; $$.typeName = $2; $$.paramName = $3; $$.val = $5; &#125;;param_type : IDENTIFIER &#123;$$=$1;&#125;;param_direct : IDENTIFIER &#123;$$=$1;&#125;;%%void yy::FlounderFileParser::error(const location_type&amp; l, const std::string&amp; m)&#123; return;&#125; 编译123456789101112131415161718//main.cpp#include "test.tab.hh"#include &lt;stdio.h&gt;using namespace yy;using namespace std;extern FILE* yyin;static FlounderFile f;int main(int argc, char* argv[])&#123; FlounderFileParser parser(f); yyin = fopen("./barrelrpc.if", "r"); parser.set_debug_level(true); parser.parse(); return 0;&#125; 12345678910111213141516# Makefilerpc-compiler: lex.o parser.o main.cpp g++ -std=c++11 -g -lm -o test lex.o parser.o main.cpplex.o: test.l parser.o flex test.l g++ -c -o lex.o lex.yy.cparser.o: test.yy bison test.yy g++ -c -o parser.o test.tab.cc.PHONY: clean runclean: rm *.hh *.cc lex.yy.c *.o 文档Bison文档中Calc++一节有非常详细的教程。 Bison]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>bison</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用chroot搭建Barrelfish应用程序的编译环境]]></title>
    <url>%2F2017%2F07%2F02%2F%E4%BD%BF%E7%94%A8chroot%E6%90%AD%E5%BB%BABarrelfish%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[背景Barrelfish是微软开发的一个开源操作系统。为了研究该系统目前基础设施的完善程度，需要移植一些Linux下的用户空间工具。本文介绍了使用chroot来搭建cross compile环境的过程。 方法比较为了编译Barrelfish平台上的应用，有两种方法。 使用Hakefile模仿Barrelfish的其他系统组件，把应用的所有源文件和库依赖都写在Hakefile中，利用Barrelfish的构建系统Hake来生成编译命令。 优点Hake会自动添加必要的编译选项，如果每个C文件都可以编译通过，只要Hakefile中的库依赖填写正确，那么链接过程基本不会出错。另外，当库的源代码发生变化后，执行make命令就可以自动重新构建应用。 缺点一些较大的工具源码文件比较多，依赖关系错综复杂，有的还需要通过宏定义来对功能进行定制。只有搞清楚所有依赖和需要的宏定义才可以写出正确的Hakefile。 在configure过程中提供所有的编译选项autoconf是linux下应用的常用构建方式，这类应用编译时分为configure和make两个步骤。在configure步骤时，在CFLAGS环境变量中加入-nostdlib和-nostdinc等参数来定义头文件和库文件的搜索位置，从而实现在make时只使用Barrelfish的头文件和库。 优点不用分析源码间的依赖关系，使用configure可以自动分析系统内可用的库函数和头文件，并生成正确的config.h。一般来说configure步骤通过之后，make步骤是很容易通过的。如果缺少必要的库函数或者头文件，那么configure步骤就会失败并有提示。 缺点与宿主系统的环境混合在一起，若应用中掺杂了一些自定义的编译步骤，不仅configure步骤有可能无法正确识别环境，生成错误的config.h，也有可能会导致目标文件中链接到宿主系统的代码，使得程序无法再Barrelfish中正确运行。 使用chroot构建编译环境使用chroot可以切换到一个空的根目录，根目录中的所有文件都是可控的，因此，编译时一定不会被宿主系统污染，也可以通过设置环境变量使得gcc在编译所有程序时，都使用Barrelfish的库和头文件。消除了第二种方法的缺点。 步骤假设新的根目录位于/my/root目录中。为了方便说明，把该目录导出到环境变量中。1export root=/my/root 挂载必要的文件系统命令如下 1234mkdir -p $root/sys $root/proc $root/devsudo mount --bind /sys $root/syssudo mount --bind /sys $root/procsudo mount --bind /sys $root/dev 复制必要的程序此时该根目录中没有任何可用的程序，如果直接使用chroot命令进入目录会有如下错误。 12&gt; sudo chroot /my/root /bin/bashchroot: failed to run command ‘/bin/bash’: No such file or directory 即使把/bin/bash复制到/my/myroot/bin中，依然会有该提示。不过注意，虽然提示相同，但是产生的原因却不同，前者是/bin/bash文件不存在，后者是bash运行所需要的动态链接库文件不存在。因此还需要复制运行时需要的动态链接库。1234567891011&gt; cp /bin/bash /my/root/bash&gt; ldd /bin/bash linux-vdso.so.1 (0x00007ffd4d7cd000) #对该项的说明见https://en.wikipedia.org/wiki/VDSO libreadline.so.7 =&gt; /usr/lib/libreadline.so.7 (0x00007f8d2bbe9000) libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007f8d2b9e5000) libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f8d2b640000) libncursesw.so.6 =&gt; /usr/lib/libncursesw.so.6 (0x00007f8d2b3d3000) /lib64/ld-linux-x86-64.so.2 (0x00007f8d2be37000)&gt; cp /usr/lib/libreadline.so.7 $root/usr/lib/libreadline.so.7&gt; cp /usr/lib/libdl.so.2 $root/usr/lib/libdl.so.2&gt; cp ... $root/... 依赖复制完后，再次使用chroot命令，就可以成功进入了。但是此时并有任何其他的工具，诸如make，ls，gcc等命令都无法使用，还需使用上面的方法把这些命令复制到$root中才可以。此外，注意复制正确的gcc平台版本，arm，x86等平台是有不同的gcc相对应。如arm版gcc一般名为arm-linux-eabi-gcc。 需要注意的是，gcc在运行时还会依赖/usr/lib/gcc/[x86_64, x86, arm]-linux-gnu/目录下的文件，否则在编译c文件时，会提示cc1命令未找到。 复制Barrelfish的头文件和库假设宿主机上Barrelfish位于$barrelfish中，chroot后位于/bar(宿主机的$root/bar)中，那么可以使用如下的命令进行复制。 假设编译的是x86_64版本，编译的目录位于$barrelfish/buildx86_64中 以下目录需要被复制 12345678910# 头文件cp $barrelfish/include $root/bar/. -ruLcp $barrelfish/lib/newlib/newlib/libc/include $root/bar/lib/newlib/newlib/libc -ruLcp $barrelfish/lib/lwip/src/include/ipv4 $root/bar/lib/lwip/src/include -ruLcp $barrelfish/lib/lwip/src/include $root/bar/lib/lwip/src -ruL# 库文件cp $barrelfish/buildx86_64/x86_64/include $root/bar/buildx86_64/x86_64 -ruLcp $barrelfish/buildx86_64/x86_64/lib $root/bar/buildx86_64/x86_64 -ruLcp $barrelfish/buildx86_64/x86_64/errors $root/bar/buildx86_64/x86_64 -ruLcp $barrelfish/buildx86_64/x86_64/usr/drivers/megaraid $root/bar/buildx86_64/x86_64/usr/drivers -ruL 配置chroot后的环境变量为了让新环境的gcc能找到正确的头文件和库，如libc等，需要设置如下环境变量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# For conveniencebarroot=/barbuild=$barroot/buildx86_64plat=x86_64# ----------------------------------# # -----影响GCC的环境变量-------------# 影响GCC的头文件搜索路径，该环境变量定义的路径优先级 &lt; -I定义的路径 &lt; 默认搜索路径。好处是任何时候调用GCC都起作用，缺点是优先级太低。export C_INCLUDE_PATH="$&#123;barroot&#125;/include:$&#123;barroot&#125;/include/arch/x86_64:$&#123;barroot&#125;/lib/newlib/newlib/libc/include:$&#123;barroot&#125;/include/c:$&#123;barroot&#125;/include/target/x86_64:$&#123;barroot&#125;/lib/lwip/src/include/ipv4:$&#123;barroot&#125;/lib/lwip/src/include:$&#123;build&#125;/$&#123;plat&#125;/include"# 影响库文件搜索路径export LIBRARY_PATH="$&#123;build&#125;/$&#123;plat&#125;/lib $&#123;build&#125;/$&#123;plat&#125;/errors"# ----------------------------------## -----影响configure的环境变量--------export CFLAGS="-std=c99 -static -U__STRICT_ANSI__ -Wstrict-prototypes -Wold-style-definition \ -Wmissing-prototypes -fno-omit-frame-pointer -fno-builtin -nostdinc -nostdlib -U__linux__ \ -Ulinux -Wall -Wshadow -Wmissing-declarations -Wmissing-field-initializers -Wtype-limits \ -Wredundant-decls -m64 -mno-red-zone -fPIE -fno-stack-protector -Wno-unused-but-set-variable \ -Wno-packed-bitfield-compat -Wno-frame-address -D__x86__ -DBARRELFISH -DBF_BINARY_PREFIX=\"\" \ -D_WANT_IO_C99_FORMATS -DCONFIG_LAZY_THC -DCONFIG_SVM -DUSE_KALUGA_DVM -DCONFIG_INTERCONNECT_DRIVER_LMP \ -DCONFIG_INTERCONNECT_DRIVER_UMP -DCONFIG_INTERCONNECT_DRIVER_MULTIHOP \ -DCONFIG_INTERCONNECT_DRIVER_LOCAL -DCONFIG_FLOUNDER_BACKEND_LMP \ -DCONFIG_FLOUNDER_BACKEND_UMP -DCONFIG_FLOUNDER_BACKEND_MULTIHOP \ -DCONFIG_FLOUNDER_BACKEND_LOCAL -Wpointer-arith -Wuninitialized \ -Wsign-compare -Wformat-security -Wno-pointer-sign -Wno-unused-result \ -fno-strict-aliasing -D_FORTIFY_SOURCE=2 \ -I$&#123;barroot&#125;/include -I$&#123;barroot&#125;/include/arch/x86_64 \ -I$&#123;barroot&#125;/lib/newlib/newlib/libc/include -I$&#123;barroot&#125;/include/c -I$&#123;barroot&#125;/include/target/x86_64 \ -I$&#123;barroot&#125;/lib/lwip/src/include/ipv4 -I$&#123;barroot&#125;/lib/lwip/src/include -I$&#123;build&#125;/$&#123;plat&#125;/include"# 还有个环境变量名叫LDFLAGS，该变量在gcc调用命令中的展开位置位于输入文件之前，会导致undefined references错误。export LIBS="-Wl,-z,max-page-size=0x1000 -Wl,--build-id=none $&#123;build&#125;/$&#123;plat&#125;/lib/crt0.o \ $&#123;build&#125;/$&#123;plat&#125;/lib/crtbegin.o $&#123;build&#125;/$&#123;plat&#125;/lib/libssh.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libopenbsdcompat.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libzlib.a $&#123;build&#125;/$&#123;plat&#125;/lib/libposixcompat.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libterm_server.a $&#123;build&#125;/$&#123;plat&#125;/lib/libvfs.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libahci.a $&#123;build&#125;/$&#123;plat&#125;/lib/libmegaraid.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libnfs.a $&#123;build&#125;/$&#123;plat&#125;/lib/liblwip.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libnet_if_raw.a $&#123;build&#125;/$&#123;plat&#125;/lib/libtimer.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libhashtable.a $&#123;build&#125;/$&#123;plat&#125;/lib/libbarrelfish.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libterm_client.a $&#123;build&#125;/$&#123;plat&#125;/lib/liboctopus_parser.a \ $&#123;build&#125;/$&#123;plat&#125;/errors/errno.o $&#123;build&#125;/$&#123;plat&#125;/lib/libnewlib.a \ $&#123;build&#125;/$&#123;plat&#125;/lib/libcompiler-rt.a $&#123;build&#125;/$&#123;plat&#125;/lib/crtend.o \ $&#123;build&#125;/$&#123;plat&#125;/lib/libcollections.a" # ------------------------------------# # 环境变量展开位置# gcc $&#123;CFLAGS&#125; $&#123;程序定义的flags&#125; $&#123;LDFLAGS, 一系列-l命令&#125; $&#123;程序指定的库&#125; -o &lt;output&gt; &lt;inputs...&gt; $&#123;LIBS&#125; 把以上脚本放置在$root/env.sh中，每次chroot后，都使用source /env.sh命令引入。也可在.bashrc文件中加入source命令，启动时自动引入环境变量。 编译程序本章以编译grep命令为例。复制文件所用的自动化脚本来自BarrelfishTools仓库的cpbin.sh文件。123456789101112131415161718➜ barrelfish git:(master) ✗ lsusr lib hake ....➜ barrelfish git:(master) ✗ pwd/home/sunsijie/image/barrelfish➜ barrelfish git:(master) ✗ ls myrootbar bin dev sys ....➜ barrelfish git:(master) ✗ cd myroot➜ myroot git:(master) ✗ wget http://ftp.gnu.org/gnu/grep/grep-2.5.4.tar.bz2➜ myroot git:(master) ✗ tar xf grep-2.5.4.tar.bz2➜ myroot git:(master) ✗ mv grep-2.5.4 grep➜ myroot git:(master) ✗ cd ..➜ barrelfish git:(master) ✗ ./cpbin.sh........many outputsarch-sunsijie cd greparch-sunsijie mkdir buildarch-sunsijie cd buildarch-sunsijie ../configure --host=x86_64 --disable-nls --disable-perl-regexp........many outputs 此时configure步骤应该是成功的，但是编译时还是会有些问题，这是因为由于newlib实现不同于glibc，导致configure时未能正确配置一些宏定义。 第一个错误如下。 123456../../lib/strtoumax.c:55:1: error: redefinition of 'strtoumax' strtoumax (char const *ptr, char **endptr, int base) ^~~~~~~~~In file included from ../../lib/strtoumax.c:25:0:/bar/lib/newlib/newlib/libc/include/inttypes.h:322:25: note: previous definition of 'strtoumax' was here static inline uintmax_t strtoumax(const char *s, char **endp, int base) 解决方法，把$root/grep/lib/strtoumax.c文件中引用的头文件inttypes.h删除。 第二个错误如下。 123bar/buildx86_64/x86_64/lib/libcollections.a ../lib/libgreputils.a(regex.o): In function `regerror&apos;: regex.c:(.text+0xa2e4): undefined reference to `__mempcpy&apos; 解决方法，在lib/getopt.c和lib/regex.c文件中的合适位置添加__mempcpy的实现。代码如下。 1234static void* __mempcpy(void* dst, void* src, size_t n)&#123; return (void*)((char*)memcpy(dst, src, n) + n);&#125; 第三个错误 第三个错误在于没有初始化vfs，不会导致编译错误，但是会导致运行时错误。需要在$root/grep/src/grep.c:1827行插入代码vfs_init(); 之后，make通过。 使用命令12➜ barrelfish git:(master) ✗ cp myroot/grep/build/src/grep buildx86_64/x86_64/sbin/➜ barrelfish git:(master) ✗ echo &quot;module /x86_64/sbin/grep&quot; &gt;&gt; buildx86_64/platforms/x86/menu.lst.x86_64 即可在Barrelfish启动时把grep加载到ramfs中。命令运行成功的截图如下。]]></content>
      <categories>
        <category>Barrelfish</category>
      </categories>
      <tags>
        <tag>Barrelfish chroot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统领域的5会议-5期刊-5课题组]]></title>
    <url>%2F2017%2F06%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%A2%86%E5%9F%9F%E7%9A%845%E4%BC%9A%E8%AE%AE-5%E6%9C%9F%E5%88%8A-5%E8%AF%BE%E9%A2%98%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前几日听一个关于如何发表高水平论文的讲座，讲座中提到，想要知道一个领域的最新进展，一个比较好的方法是去了解该领域的5-5-5。也就是5个顶级会议、5个顶级期刊和5个顶级课题组。本博客记录了我了解到的操作系统领域的5-5-5。 会议OSDI (Operating Systems Design and Implementation)OSDI由USENIX主办，从94年开始，每两年举行一次，最新的一届是OSDI’16。诸如Bigtable, MapReduce等都是在该会议上发表的。 网址 SOSP (Symposium on Operating Systems Principles)该会议与OSDI水平不相上下，同样是OS领域的顶级会议。SOSP每两年召开一次，时间刚好与OSDI错开，两个会每年轮流开。最新的一届是SOSP’17该会议上发表过Xen, GFS等著名论文。 网址 USENIX ATC (Annual Technical Conference)USENIX Annual Techinical Conference创办于1992年,是由USENIX组织的操作系统领域重要会议，每年举办一次。 网址 EuroSYS该会议收录Computer System各个领域的论文。 网址 Middleware (International Middleware Conference)该会议主要收录有关分布式系统中间件的文章。 网址 其他FAST (USENIX Conference on File and Storage Technologies)HotOS 期刊课题组References 计算机界顶级会议排名 List of computer science conferences USENIX USNIX Conferences by Name Microsoft Academic WikiCFP]]></content>
      <categories>
        <category>论文</category>
        <category>科研</category>
      </categories>
      <tags>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Hexo博客的代码片段添加 选择全部 按钮]]></title>
    <url>%2F2017%2F06%2F06%2F%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E6%B7%BB%E5%8A%A0-%E9%80%89%E6%8B%A9%E5%85%A8%E9%83%A8-%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[Hexo生成的博客中，代码片段是不支持选择全部功能的，若代码片段较长，手动选择非常的不方便。添加的方法如下。在页面模板文件（对于Next主题，模板文件为themes/next/layout/_layout.swig）的&lt;head&gt;节点中添加如下代码。 12345678910111213141516171819202122232425262728293031323334353637383940$(document).ready(function () &#123; var SelectText = function(element) &#123; var doc = document , text = element , range, selection ; if (doc.body.createTextRange) &#123; range = document.body.createTextRange(); range.moveToElementText(text); range.select(); &#125; else if (window.getSelection) &#123; selection = window.getSelection(); range = document.createRange(); range.selectNodeContents(text); selection.removeAllRanges(); selection.addRange(range); &#125; &#125;; $(".code").each(function() &#123; var code = $(this).get(0); var button_html = '&lt;div style="position: fixed;' + 'right: 3%;' + 'margin-top: 5px;' + 'font-family: consolas, Menlo, \'PingFang SC\', \'Microsoft YaHei\', monospace;' + 'font-size: 10px;' + 'cursor: pointer;' + 'color: #e31436;' + '"&gt;' + '&lt;span&gt;全选&lt;/span&gt;' + '&lt;/div&gt;'; var button = $(button_html); $(button).click(function() &#123; SelectText(code); &#125;); $(button).insertBefore(this); &#125;);&#125;);]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Barrelfish与seL4对Capability支持的详细对比]]></title>
    <url>%2F2017%2F06%2F06%2FBarrelfish%E4%B8%8EseL4%E5%AF%B9Capability%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[概述Barrelfish采用Capability机制对系统资源进行管理，该机制源自seL4。 Capability可以看做是访问系统中各种资源的令牌。内存空间、IO端口、进程控制块（PCB），中断号，进程通信的信道等，都可以通过Capability来管理。 内核通常会在内核空间维护每个进程所持有的Capability的详细数据，而用户进程持有Capability的引用。当用户程序访问系统资源时，需要使用该资源对应的Capability的引用调用系统调用，内核检查该引用的合法性后，才会允许用户对该资源进行操作。 Capability的类型Capability的类型通常与资源一一对应。 对于内存区域，内核中的Capability可以表示如下。 12345struct PhysAddr_Cap &#123; enum objtype_t type = PHYS_ADDR; addr_t base; // 内存基地址 int bytes; // 字节数&#125;; 对于PCB，内核中的Capability可以表示如下。 123456789101112struct pcb &#123; pid_t pid; pid_t parent; register_t regs[]; enum state_t state; ... //进程控制块的其他内容&#125;;struct PCB_Cap &#123; enum objtype_t type = PCB; struct pcb *pcb;&#125;; 对于IRQ中断号管理，内核可以使用如下Capability 123456struct IRQSrc_Cap &#123; enum objtype_t type = IRQSrc; //表示一个中断号的区间 int irq_start; int irq_end;&#125;; 对于通信信道，内核可以使用如下Capability 123456struct EndPoint_Cap &#123; enum objtype_t type = EndPoint; struct pcb* receiver; // 接收进程 char* buffer; size_t buffer_size;&#125;; 还有些资源对应的Capability，可能不需要额外的信息存储 123struct [IPI, Null, IRQTable] &#123; //分别表示核间终端(Inter Processor Interrupt)和空 enum objtype_t type = ...;&#125;; Capability的类型转换_ 关键字：Capability类型 Capability关系数据库 _ 从上节中介绍的类型中可以看出，计算机内的各种资源是有层次关系的。内存空间是最基础的一种资源，PCB、EndPoint等，都是由内存空间转换而来的。Capability的类型转换就是为了模拟这种资源的层次关系。当用户程序取得一种Capability时（通常是表示一段内存空间的RAM Capability），可以使用系统调用将该Capability转换为其他类型，内核首先通过事先定义好的规则验证该转换是否合法，若合法，则会在内核空间为该进程创建一个目标类型的Capability，并把引用返回给用户程序。类型的转换并不会导致一个Capability的删除，内核会维护新产生的Capability与源Capability间继承的关系(Capability Derivation Tree)，若用户空间重复对一个的Capability进行类型转换操作，那么内核会拒绝该操作；若进程请求删除的一个Capability有子节点，那么内核也会同时删除子节点。基于Capability的内核利用Capability的类型转换来实现普通操作系统提供的系统调用。比如，若用户空间的程序需要申请一个IRQ号，那么它需要持有IRQTable_Cap（表明具有操作内核中IRQ转发表的权限），然后使用类似于如下的系统调用。 12An_IRQSrc_Cap_Ref = cap_retype(An_IRQTable_Cap_Ref, irq_num_from, irq_num_to, irq_handler_pointer); 操作系统会进行如下几步操作。 验证程序提供的Capability Reference是否正确。 在用户进程的PCB中新建一个IRQSrc类型的Capability，并根据参数填写内核中的IRQ转发表。 在Capability关系数据库中，记录IRQSrc_Cap和IRQTable_Cap之间的转换关系。 把新产生的IRQSrc_Cap的引用返回给用户程序。 其他诸如映射页表(Ram_Cap -&gt; Frame_Cap)，创建进程间通信信道（Ram_Cap -&gt; EndPoint_Cap)等操作都有类似的过程。 Capability的其他操作 撤销（revoke） 可以禁止目标进程使用某项资源。如撤销IRQSrc可导致用户进程不再处理某些IRQ。对Frame_Cap的撤销可以导致页表映射项的删除。 复制（copy） 利用复制可以是一个进程把他拥有的一些权限继承给它的子进程。 对比要对比Capability功能，可以从Capability类型数量和支持的Capability操作两方面来对比。 Capability类型对比 Barrelfish Capability定义文件 seL4 Capability定义文件 分类 Barrelfish seL4 Null null_cap 内存空间相关 Memory untyped_cap PhysAddr Mapping VNode RAM Capability权限 Kernel Capability管理 CNode cnode_cap L1CNode zombie_cap L2CNode FCNode 进程管理与IPC Dispatcher domain_cap EndPoint endpoint_cap thread_cap notification_cap reply_cap 页表管理 Frame frame_cap Frame_Mapping DevFrame DevFrame_Mapping VNode_x86_64_pml4 asid_control_cap VNode_x86_64_pml4_Mapping asid_pool_cap VNode_x86_64_pdpt pdpt_cap VNode_x86_64_pdpt_Mapping pml4_cap VNode_x86_64_pdir page_directory_cap VNode_x86_64_pdir_Mapping page_global_directory_cap VNode_x86_64_ptable page_table_cap VNode_x86_64_ptable_Mapping page_upper_directory_cap VNode_x86_32_pdpt small_frame_cap VNode_x86_32_pdpt_Mapping VNode_x86_32_pdir VNode_x86_32_pdir_Mapping VNode_x86_32_ptable VNode_x86_32_ptable_Mapping VNode_ARM_l1 VNode_ARM_l1_Mapping VNode_ARM_l2 VNode_ARM_l2_Mapping VNode_AARCH64_l0 VNode_AARCH64_l0_Mapping VNode_AARCH64_l1 VNode_AARCH64_l1_Mapping VNode_AARCH64_l2 VNode_AARCH64_l2_Mapping VNode_AARCH64_l3 VNode_AARCH64_l3_Mapping IO及IRQ IRQTable io_page_table_cap IRQDest io_port_cap IRQSrc io_space_cap IO irq_control_cap irq_handler_cap 多核管理 Notify_IPI ID PerfMon KernelControlBlock IPI 虚拟化 vcpu_cap ept_pd_cap ept_pdpt_cap ept_pml4_cap ept_pt_cap 以上为所有架构的Capability汇总。 seL4中Capability类型由如下命令获得。 grep -r &quot;tag[[:blank:]]\+\w\+_cap[[:blank:]]\+\w\+&quot; -h --include=&quot;*.bf&quot; | sed -e &#39;s/tag//&#39; -e &#39;s/^\ \+//&#39; -e &#39;s/\w\+$//&#39; | tr -d &#39; &#39; | sort | uniq EPT(Extended Page Table) Capability操作对比 Barrelfish seL4 操作描述 sys_create/sys_retype UntypedRetype caps_revoke CNodeRevoke caps_delete CNodeDelete sys_copy_or_mint CNodeCopy CNodeMint CNodeMove CNodeMutate CNodeRotate Barrelfish的Capability支持跨核的Delete Barrelfish的Retype操作具有更丰富的语义，比如可以从 Dspather Capability retype 为 Endpoint Capability。]]></content>
      <categories>
        <category>Barrelfish</category>
      </categories>
      <tags>
        <tag>Barrelfish</tag>
        <tag>seL4</tag>
        <tag>操作系统</tag>
        <tag>Capability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的vimrc]]></title>
    <url>%2F2017%2F06%2F05%2F%E6%88%91%E7%9A%84vimrc%2F</url>
    <content type="text"><![CDATA[采用Vundle对插件进行管理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200set nusyntax onset smartindentset smarttabset sw=4 ts=4 sts=4set wildmenuset mousemodel=popupset cul cuc "高亮光标所在行set rulerset scrolloff=4set laststatus=2set history=1000set t_Co=256set autoread autowriteset confirmset nobackup noswapfileset hlsearch incsearch smartcaseset showmatchset selectmode=mouse,keyset nocompatible " be iMproved, requiredfiletype off " required" set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()" alternatively, pass a path where Vundle should install plugins"call vundle#begin('~/some/path/here')" let Vundle manage Vundle, requiredPlugin 'VundleVim/Vundle.vim'" The following are examples of different formats supported." Keep Plugin commands between vundle#begin/end." plugin on GitHub repoPlugin 'tpope/vim-fugitive'" plugin from http://vim-scripts.org/vim/scripts.html" Plugin 'L9'" Git plugin not hosted on GitHubPlugin 'git://git.wincent.com/command-t.git'" git repos on your local machine (i.e. when working on your own plugin)" Plugin 'file:///home/gmarik/path/to/plugin'" The sparkup vim script is in a subdirectory of this repo called vim." Pass the path to set the runtimepath properly.Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;" Install L9 and avoid a Naming conflict if you've already installed a" different version somewhere else." Plugin 'ascenator/L9', &#123;'name': 'newL9'&#125;Plugin 'scrooloose/nerdtree'Plugin 'scrooloose/nerdcommenter'Plugin 'altercation/vim-colors-solarized'Plugin 'godlygeek/tabular'Plugin 'plasticboy/vim-markdown'Plugin 'iamcco/mathjax-support-for-mkdp'Plugin 'iamcco/markdown-preview.vim'Plugin 'jiangmiao/auto-pairs'Plugin 'vim-signature'Plugin 'easymotion/vim-easymotion'Plugin 'haya14busa/incsearch.vim'Plugin 'haya14busa/incsearch-easymotion.vim'Plugin 'a.vim'Plugin 'majutsushi/tagbar'Plugin 'vim-airline/vim-airline'Plugin 'Valloric/YouCompleteMe'Plugin 'rdnetto/YCM-Generator'Plugin 'vimwiki/vimwiki'Plugin 'skywind3000/asyncrun.vim'" All of your Plugins must be added before the following linecall vundle#end() " requiredfiletype plugin indent on " required" To ignore plugin indent changes, instead use:"filetype plugin on"" Brief help" :PluginList - lists configured plugins" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate" :PluginSearch foo - searches for foo; append `!` to refresh local cache" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal"" see :h vundle for more details or wiki for FAQ" Put your non-Plugin stuff after this line"" 设置主题let g:solarized_termcolors=256set background=darkcolorscheme solarized" 配置NerdTree ************************************************************************" autocmd vimenter * if !winbufnr(0) | NERDTree | endif "当打开vim且没有文件时自动打开NERDTreemap &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt; :NERDTreeToggle&lt;CR&gt;" 配置NerdTree ************************************************************************" 配置EasyMotion " *********************************************************************" &lt;Leader&gt;f&#123;char&#125; to move to &#123;char&#125;map &lt;Leader&gt;f &lt;Plug&gt;(easymotion-bd-f)nmap &lt;Leader&gt;f &lt;Plug&gt;(easymotion-overwin-f)" s&#123;char&#125;&#123;char&#125; to move to &#123;char&#125;&#123;char&#125;nmap s &lt;Plug&gt;(easymotion-overwin-f2)" Move to linemap &lt;Leader&gt;L &lt;Plug&gt;(easymotion-bd-jk)nmap &lt;Leader&gt;L &lt;Plug&gt;(easymotion-overwin-line)" Move to wordmap &lt;Leader&gt;w &lt;Plug&gt;(easymotion-bd-w)nmap &lt;Leader&gt;w &lt;Plug&gt;(easymotion-overwin-w)" You can use other keymappings like &lt;C-l&gt; instead of &lt;CR&gt; if you want to" use these mappings as default search and somtimes want to move cursor with" EasyMotion.function! s:incsearch_config(...) abort return incsearch#util#deepextend(deepcopy(&#123; \ 'modules': [incsearch#config#easymotion#module(&#123;'overwin': 1&#125;)], \ 'keymap': &#123; \ "\&lt;CR&gt;": '&lt;Over&gt;(easymotion)' \ &#125;, \ 'is_expr': 0 \ &#125;), get(a:, 1, &#123;&#125;))endfunctionnoremap &lt;silent&gt;&lt;expr&gt; / incsearch#go(&lt;SID&gt;incsearch_config())noremap &lt;silent&gt;&lt;expr&gt; ? incsearch#go(&lt;SID&gt;incsearch_config(&#123;'command': '?'&#125;))noremap &lt;silent&gt;&lt;expr&gt; g/ incsearch#go(&lt;SID&gt;incsearch_config(&#123;'is_stay': 1&#125;))nnoremap &lt;Esc&gt;&lt;Esc&gt; :&lt;C-u&gt;nohlsearch&lt;CR&gt;" 配置EasyMotion " *********************************************************************" 配置airline " ***********************************************************************let g:airline#extensions#tabline#enabled = 1" 配置airline " ***********************************************************************" 配置TagBar ××××××××××××××××××××××××××××××××nmap &lt;F8&gt; :TagbarToggle&lt;CR&gt;" 配置TagBar ××××××××××××××××××××××××××××××××" 配置YCM***************************************let g:ycm_show_diagnostics_ui = 1let g:ycm_confirm_extra_conf = 0let g:ycm_seed_identifiers_with_syntax = 0let g:ycm_key_invoke_completion='&lt;C-i&gt;'" 配置YCM***************************************" 自定义快捷键 ******************************************map &lt;C-L&gt; :tabnext&lt;CR&gt;map &lt;C-H&gt; :tabprev&lt;CR&gt;" 自定义快捷键 ******************************************" 配置Command-t *****************************************nmap &lt;silent&gt; &lt;Leader&gt;t &lt;Plug&gt;(CommandT)nmap &lt;silent&gt; &lt;Leader&gt;b &lt;Plug&gt;(CommandTBuffer)nmap &lt;silent&gt; &lt;Leader&gt;j &lt;Plug&gt;(CommandTJump)" 配置Command-t *****************************************" 自动编译 *********************************************"map &lt;F5&gt; :copen&lt;CR&gt;:wincmd k&lt;CR&gt;:AsyncRun g++ -o %&lt; %&lt;CR&gt;map &lt;F5&gt; :copen&lt;CR&gt;:wincmd k&lt;CR&gt;:AsyncRun sudo ./build.sh make&lt;CR&gt;map &lt;Leader&gt;&lt;F5&gt; :copen&lt;CR&gt;:wincmd k&lt;CR&gt;:AsyncRun g++ -o %&lt; %;./%&lt;&lt;CR&gt;" 自动编译 *********************************************"***** Markdown **************************set conceallevel=2let g:vim_markdown_math = 1let g:vim_markdown_frontmatter = 1let g:vim_markdown_folding_disabled = 1let g:mkdp_path_to_chrome = "chromium"" 设置 chrome 浏览器的路径（或是启动 chrome（或其他现代浏览器）的命令）let g:mkdp_auto_start = 1" 设置为 1 可以在打开 markdown 文件的时候自动打开浏览器预览，只在打开" markdown 文件的时候打开一次let g:mkdp_auto_open = 1" 设置为 1 在编辑 markdown 的时候检查预览窗口是否已经打开，否则自动打开预" 览窗口let g:mkdp_auto_close = 1" 在切换 buffer 的时候自动关闭预览窗口，设置为 0 则在切换 buffer 的时候不" 自动关闭预览窗口let g:mkdp_refresh_slow = 0" 设置为 1 则只有在保存文件，或退出插入模式的时候更新预览，默认为 0，实时" 更新预览let g:mkdp_command_for_global = 0" 设置为 1 则所有文件都可以使用 MarkdownPreview 进行预览，默认只有 markdown" 文件可以使用改命令"****************************************nmap &lt;Leader&gt;k :m-2&lt;CR&gt;nmap &lt;Leader&gt;j :m+&lt;CR&gt;]]></content>
      <categories>
        <category>配置文件</category>
      </categories>
      <tags>
        <tag>配置文件</tag>
        <tag>vim</tag>
      </tags>
  </entry>
</search>
